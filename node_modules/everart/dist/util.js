"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContentType = exports.uploadFile = exports.sleep = exports.EverArtError = exports.downloadImage = exports.makeUrl = exports.DEFAULT_OUTPUT_FORMAT = exports.APIVersion = void 0;
const axios_1 = __importStar(require("axios"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const uuid_1 = require("uuid");
const EVERART_BASE_URL = 'https://api.everart.ai';
var APIVersion;
(function (APIVersion) {
    APIVersion["V1"] = "v1";
})(APIVersion || (exports.APIVersion = APIVersion = {}));
exports.DEFAULT_OUTPUT_FORMAT = 'png';
// HELPER FUNCTIONS
function makeUrl(verison, endpoint) {
    return `${EVERART_BASE_URL}/${verison}/${endpoint}`;
}
exports.makeUrl = makeUrl;
/**
 * Download an image from a URL and return the local file path
 *
 * @param url
 * @returns filepath string
 */
async function downloadImage(url) {
    let ext = url.split('.').pop() || 'png';
    if (!['jpg', 'jpeg', 'png', 'webp'].includes(ext)) {
        ext = 'png';
    }
    const filename = `image-${(0, uuid_1.v4)()}.${ext}`;
    const filepath = path_1.default.join(os_1.default.tmpdir(), filename);
    const response = await (0, axios_1.default)({
        url,
        method: 'GET',
        responseType: 'stream',
    });
    await fs_extra_1.default.ensureDir(path_1.default.dirname(filepath));
    await new Promise(async (resolve, reject) => {
        try {
            response.data
                .pipe(fs_extra_1.default.createWriteStream(filepath))
                .on('error', reject)
                .once('close', () => resolve(filepath));
        }
        catch (err) {
            reject(err);
        }
    });
    return filepath;
}
exports.downloadImage = downloadImage;
class EverArtError extends Error {
    constructor(status, message, data) {
        let dataMessage;
        try {
            dataMessage = JSON.stringify(data);
        }
        catch {
            dataMessage = '';
        }
        const fullMessage = `${message}: ${dataMessage}`;
        super(fullMessage);
        let name = 'EverArtUnknownError';
        switch (status) {
            case 400:
                name = 'EverArtInvalidRequestError';
                break;
            case 401:
                name = 'EverArtUnauthorizedError';
                break;
            case 403:
                name = 'EverArtForbiddenError';
                break;
            case 451: // Using 451 for content moderation (Legal reasons to block content)
                name = 'EverArtContentModerationError';
                break;
            case 404:
                name = 'EverArtRecordNotFoundError';
                break;
        }
        this.name = name;
    }
}
exports.EverArtError = EverArtError;
async function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
exports.sleep = sleep;
/**
 * Uploads a file to a pre-signed URL obtained from the images.uploads endpoint
 * @param filePath Local path to the file to upload
 * @param uploadUrl Pre-signed URL to upload to
 * @param contentType MIME type of the file
 */
async function uploadFile(filePath, uploadUrl, contentType) {
    var _a, _b;
    const fileStream = fs_extra_1.default.createReadStream(filePath);
    try {
        await axios_1.default.put(uploadUrl, fileStream, {
            headers: {
                'Content-Type': contentType,
            },
            maxBodyLength: Infinity,
        });
    }
    catch (err) {
        let status = 500;
        let data = undefined;
        if (err instanceof axios_1.AxiosError) {
            status = ((_a = err.response) === null || _a === void 0 ? void 0 : _a.status) || 500;
            data = (_b = err.response) === null || _b === void 0 ? void 0 : _b.data;
        }
        throw new EverArtError(status, 'Failed to upload file', data);
    }
    finally {
        fileStream.destroy();
    }
}
exports.uploadFile = uploadFile;
function getContentType(filename) {
    const ext = path_1.default.extname(filename).toLowerCase();
    switch (ext) {
        case '.jpg':
        case '.jpeg':
            return 'image/jpeg';
        case '.png':
            return 'image/png';
        case '.webp':
            return 'image/webp';
        case '.heic':
            return 'image/heic';
        case '.heif':
            return 'image/heif';
        default:
            throw new Error(`Unsupported file extension: ${ext}`);
    }
}
exports.getContentType = getContentType;
//# sourceMappingURL=util.js.map